# ДЗ - 2 СУБД АДминистрирование


## Работа с БД через сервисную учетную запись

Для начала разберем имеющиеся схемы в таблиц и количество обновлений

---

### Таблица `subscription_types`

Таблица `subscription_types` хранит данные о различных типах подписок, которые доступны пользователям.

Нету необходимости изменять эту таблицу, так как все виды подписок задаются заранее и должны изменяться только superuserом, обычный пользователь может лишь посмотреть виды подписок и их условия

**Установленные разрешения**
- SELECT

---


### Таблица `complaint_types`

Таблица `complaint_types` хранит типы жалоб, которые могут быть поданы пользователями.

Нету необходимости изменять эту таблицу, так как все виды жалоб задаются заранее для удобства администрирования и должны изменяться только superuserом, обычный пользователь может лишь получить их типы для заполнения формы 

**Установленные разрешения**
- SELECT

---



### Таблица `notification_types`

Таблица `notification_types` хранит типы уведомлений, которые получают пользователи.

Нету необходимости изменять эту таблицу, так как все виды уведомлений задаются заранее для удобства администрирования и должны изменяться только superuserом, обычный пользователь может лишь получить их типы для выдачи уведомлений

**Установленные разрешения**
- SELECT

---



### Таблица `queries`

Таблица `queries` хранит опросы, которые получают пользователи.

Нету необходимости изменять эту таблицу, так как все виды опросов задаются заранее для удобства администрирования и должны изменяться только superuserом, обычный пользователь может лишь получить их для прохождения

**Установленные разрешения**
- SELECT

---


### Таблица `admins`

Таблица `admins` хранит аккаунты админов

Нету необходимости изменять эту таблицу, так как все админы задаются и назначаются superuserом, обычный пользователь не имеет права доступа к ним

**Установленные разрешения**
- SELECT

---


### Остальные таблицы

#### Таблица `static`
Таблица `static` хранит информацию о статичных данных, таких как изображения или другие файлы, загружаемые пользователями или системой.

---

#### Таблица `sessions`
Таблица `sessions` хранит данные о сессиях пользователей. Каждая запись представляет собой активную сессию пользователя с уникальным токеном для аутентификации.

---

#### Таблица `users`
Таблица `users` хранит информацию о пользователях системы, включая их личные данные и учетные записи.

---

#### Таблица `user_answer`
Таблица `user_answer` хранит информацию об ответах пользователей на опросы

---

#### Таблица `profiles`

Таблица `profiles` содержит информацию о профилях пользователей, таких как их имя, дата рождения, местоположение и описание.

---

#### Таблица `interests`

Таблица `interests` хранит интересы, которые могут быть связаны с профилями пользователей.


---

#### Таблица `profile_interests`

Таблица `profile_interests` служит для связи профилей с их интересами, реализуя связь многие ко многим между таблицами `profiles` и `interests`.


---

#### Таблица `profile_ratings`

Таблица `profile_ratings` служит для хранения отзывов на конкретный профиль с рейтингом и тестовыми пояснениями

---


#### Таблица `notifications`

Таблица `notifications` служит для хранения уведомлений, которые требуется отдать пользователям

---

#### Таблица `preferences`

Таблица `preferences` хранит данные о предпочтениях пользователей, такие как предпочтения по возрасту, городу и другим факторам.

---

#### Таблица `profile_preferences`

Таблица `profile_preferences` служит для связи профилей с их предпочтениями, реализуя связь многие ко многим между таблицами `profiles` и `preferences`.

---

#### Таблица `locations`

Таблица `locations` хранит данные о местоположениях, которые могут быть связаны с профилями пользователей.

---

#### Таблица `messages`

Таблица `messages` хранит данные о сообщениях, отправленных между профилями пользователей.

---

#### Таблица `likes`

Таблица `likes` хранит данные о том, какие профили нравятся другим профилям. Это используется для моделирования лайков между пользователями.


---

#### Таблица `matches`

Таблица `matches` хранит данные о совпадениях между профилями. Совпадение происходит, когда два профиля выразили интерес друг к другу (например, лайкнули друг друга).

---

#### Таблица `chats`

Таблица `chats` хранит данные о чатах, которые созданы пользователями

---

#### Таблица `subscriptions`

Таблица `subscriptions` хранит данные о подписках пользователей на различные типы сервисов.

---

#### Таблица `complaints`

Таблица `complaints` хранит данные о жалобах пользователей на другие профили или на систему в целом.


---

#### Таблица `blacklist`

Таблица `blacklist` хранит данные о пользователях, заблокированных на платформе.

К остальным таблицам приложению необходим доступ не только на чтение, но и на запись, редактирование и  удаление

**Установленные разрешения**
- SELECT
- INSERT
- UPDATE
- DELETE


Код подключения хранится в папке repository/db/03_permissions

Этот код выполняется сразу после инициализации 

## Защита от SQL Injections

Для подключения к SQL используется библиотека pgx и "database/sql", все запросы пишутся явно
Подключение идет через *sql.DB

Для экранирования в запросах используются позиционные параметры в SQL-запросе.

Они используются вместо прямой подстановки значений в SQL-строку, чтобы:

- Защититься от SQL-инъекций.
- Упростить работу с типами данных.
- Повысить читаемость и повторное использование SQL-запросов.

Например в запросе на добавление сообщения
```sql
INSERT INTO chats (first_profile_id, second_profile_id, last_message, last_sender)
		VALUES ($1, $2, $3, $4)
		ON CONFLICT (first_profile_id, second_profile_id) DO NOTHING
		RETURNING chat_id;
```


### Организация тестирования

Для тестирования используется утилита sqlmap. Сценерий тестирования выглядит так

```sh
LOGIN_USER_URL="http://localhost:8080/users/login"
sqlmap -u "$LOGIN_USER_URL" --method POST \
  --data='{"login": "testuser", "password": "password123"}' \
  --headers="Content-Type: application/json" \
  --cookie="$COOKIE" \
  --risk=3 --level=5 --batch --ignore-code="500,400,403"

```

- LOGIN_USER_URL UQL тестирования запроса
- --data= передаваемые в post запросе параметры
-  --cookie= - куки для подключения
- --ignore-code= - коды, которые игнорируют ошибки с HTTP-статусом, это означает что данные или неверны по формату или пользователь не авторизован

#### Запись тестирования на инъекции с помощью sqlmap

```
https://asciinema.org/a/C4JcIX2bLKKoXhG62qMMA06A7
```

## Пул соединений и параметры соединений

### listen_addresses

Этот параметр влияет на доступность вашей СУБД как для локальных приложений, так и для удаленных клиентов.
Для listen_addresses было добавлено 2 адреса 

- 213.219.214.83 - внешний адрес приложения, сервер должен иметь возможность подключаться к приложению, клиент должен иметь права на работу с БД
-localhost - для отладки

### max_connections
```
max_connections = 200		
```
Количество соединений в max_connections зависит от предполагаемой нагрузки на систему. 
Ожидается, что в приложение будет заходить 1000 пользователей за час. Установив значение в 200, мы оставляем достаточно места для обработки одновременных подключений, но не перегружаем СУБД лишними соединениями, что оптимизирует использование памяти и процессора.


### superuser_reserved_connections

```
superuser_reserved_connections = 3
```

Параметр резервирует определенное количество соединений для суперпользователя (например, администратора), чтобы в случае перегрузки или нехватки соединений было гарантированное количество свободных соединений для работы с базой данных.
Значение 3 — это стандартное значение, которое подходит большинству приложений. Оно позволяет администраторам базы данных поддерживать связь с сервером в случае, если количество активных соединений близко к пределу.

## Настройка параметров сервера и клиента


### shared_preload_libraries = 'pg_stat_statements,autoexplain'

Параметр **shared_preload_libraries** необходим для загрузки расширений, которые собирают статистику запросов и выполняют автологирование объяснений. В данном случае включены два расширения:
- **pg_stat_statements** — для сбора статистики по выполнению SQL-запросов. Это расширение позволяет отслеживать самые медленные и часто выполняемые запросы, что полезно для диагностики проблем с производительностью.
- **autoexplain** — для автоматического логирования планов выполнения запросов, что помогает выявлять неэффективные запросы. Он записывает планы только для запросов, длительность которых превышает заданный порог.

### pg_stat_statements

- **pg_stat_statements.track = all** — этот параметр отслеживает все запросы, независимо от их успешности или ошибки. Это полезно для комплексной диагностики, когда нужно учитывать даже неудачные запросы.
- **pg_stat_statements.max = 10000** — устанавливается максимальное количество уникальных запросов, которые могут быть записаны в статистику. Значение 10000 выбрано для того, чтобы сохранять достаточно данных о выполнении запросов без чрезмерного потребления памяти.

### autoexplain

- **autoexplain.log_min_duration = '5000ms'** — порог, при котором начинают логироваться планы выполнения запросов. Запросы, которые выполняются дольше 5000 миллисекунд (5 секунд), будут автоматически логироваться с объяснением. Это помогает выявить запросы с длительным временем выполнения, которые могут требовать оптимизации.
- **autoexplain.log_analyze = on** — включает логирование анализа запроса, что позволяет получить информацию о реальном времени выполнения запросов, включая информацию о чтении/записи данных.
- **autoexplain.log_buffers = on** — включает запись статистики по буферам, которая позволяет понять, сколько данных было прочитано или записано в процесс выполнения запроса.
- **autoexplain.log_timing = on** — включает временную информацию о выполнении, что важно для анализа производительности и определения узких мест в запросах.

### Логирование ошибок и медленных запросов

- **log_destination = 'csvlog'** — выбирается формат **csvlog**, так как он удобен для последующего анализа и использования с инструментами, такими как PGBadger.
- **logging_collector = on** — включает сбор логов в файлы, что позволяет сохранять все данные о выполненных запросах и ошибках.
- **log_directory = 'log'** — указана директория, в которой будут храниться логи. Это стандартное значение для организации логов на сервере.
- **log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'** — формат имени лог-файла, включающий дату и время. Это позволяет избежать перезаписи логов и упрощает управление архивами логов.
- **log_rotation_age = 1d** — логи будут ротироваться ежедневно, что позволяет сохранять свежие данные и предотвращать переполнение диска.
- **log_rotation_size = 10MB** — логи будут ротироваться, если их размер превысит 10 MB. Это ограничение помогает предотвратить накопление слишком больших файлов.

### Уровень логирования

- **log_min_messages = warning** — устанавливает уровень логирования на **warning**, что означает, что будут логироваться предупреждения и более серьезные сообщения (ошибки, фатальные события). Это помогает отслеживать возможные проблемы, не перегружая лог-файлы излишними сообщениями.
- **log_min_error_statement = warning** — логируются только ошибки с уровнем **warning** и выше. Это позволяет избежать логирования мелких ошибок и сосредоточиться на более серьезных проблемах.
- **log_min_duration_statement = 5000** — логируются только запросы, которые выполняются дольше 5000 миллисекунд (5 секунд). Это позволяет отслеживать медленные запросы, которые могут требовать оптимизации, не загружая систему мелкими запросами с быстрой обработкой.

### Тайм-ауты

- **STATEMENT_TIMEOUT = 60000** — максимальное время выполнения запроса составляет 60 секунд (1 минута). Если запрос не завершается за это время, он будет автоматически прерван. Это помогает избежать зависания долгих запросов.
- **lock_timeout = 30000** — время ожидания блокировки составляет 30 секунд. Это означает, что запросы, которые пытаются захватить блокировку, будут прерваны, если они не могут это сделать в течение 30 секунд. Это помогает избежать блокировок, которые могут замедлить работу системы.

Эти настройки направлены на оптимизацию производительности базы данных, улучшение мониторинга и диагностики, а также упрощение анализа и отладки запросов.
